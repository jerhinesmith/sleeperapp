#!/usr/bin/env ruby
# frozen_string_literal: true

#
# LLM Prompt Generator for Sleeper Weekly Summary
# - Takes JSON output from weekly_summary script
# - Generates structured prompt for fun family-banter weekly summary
# - Supports dotenv for configuration
#
# Usage:
#   bin/generate_llm_prompt [--input path] [--output path]
#   bin/weekly_summary auto | bin/generate_llm_prompt
#

require 'json'
require 'time'

# Load environment variables if available
begin
  require 'dotenv/load'
rescue LoadError
  # dotenv not available, continue without it
end

# Load our configuration system
require_relative '../lib/config_loader'

class LLMPromptGenerator # rubocop:disable Metrics/ClassLength
  def initialize
    @json_data = nil
  end

  def generate_prompt(json_input)
    @json_data = parse_json_input(json_input)

    prompt_sections = [
      build_header,
      build_context_section,
      build_matchup_instructions,
      build_transaction_instructions,
      build_special_sections_instructions,
      build_tone_and_format_instructions,
      build_data_section
    ]

    prompt_sections.join("\n\n")
  end

  private

  def parse_json_input(input)
    case input
    when String
      JSON.parse(input)
    when Hash
      input
    else
      raise "Invalid input type: #{input.class}"
    end
  rescue JSON::ParserError => e
    raise "Invalid JSON input: #{e.message}"
  end

  def build_header
    <<~HEADER
      # üèà Weekly Fantasy Football Summary Generator

      You are tasked with creating a fun, family-friendly fantasy football weekly summary with lots of playful banter and personality.
    HEADER
  end

  def build_context_section
    league_name = @json_data.dig('league_info', 'name') || 'Fantasy League'
    week = @json_data['week']

    # Get relationship context
    owner_names = extract_owner_names
    relationships = ConfigLoader.find_relationship_context(owner_names)

    relationship_context = if relationships.any?
                             "\n\n**Family/Friend Relationships:**\n#{relationships.map do |rel|
                               "- #{rel}"
                             end.join("\n")}"
                           else
                             ''
                           end

    # Add team-to-owner mappings for clarity
    team_mappings_context = build_team_mappings_context

    <<~CONTEXT
      ## League Context

      **League:** #{league_name}
      **Week:** #{week}
      **Generated:** #{@json_data['generated_at']}

      This is a family/friend league where good-natured ribbing and playful trash talk are encouraged. Keep the tone light, fun, and engaging while highlighting the key storylines from this week.#{relationship_context}#{team_mappings_context}
    CONTEXT
  end

  def build_matchup_instructions
    <<~MATCHUPS
      ## üìä Matchup Analysis Instructions

      For each matchup, provide:

      1. **Matchup Result Summary** - Winner, final score, margin of victory
      2. **Key Performances** - Highlight standout players (both good and bad)
      3. **Transaction Impact Analysis** - Did any waiver wire pickups or recent adds help this week?
      4. **Bench Analysis** - Point out any bench players who would have made a difference if started
      5. **Playful Commentary** - Add some family-friendly banter about the teams/owners

      Focus on storytelling and making each matchup feel like a mini-drama with heroes, villains, and plot twists.
    MATCHUPS
  end

  def build_transaction_instructions
    <<~TRANSACTIONS
      ## üíº Weekly Transaction Summary Instructions

      Create a "Waiver Wire Report" section that covers:

      1. **Most Active Managers** - Who was busy on the waiver wire?
      2. **Smart Pickups** - Which adds paid off immediately?
      3. **Questionable Drops** - Anyone drop someone who scored well?
      4. **Waiver Wire Winners/Losers** - Who made the best/worst moves?

      Make this feel like insider trading analysis but for fantasy football.
    TRANSACTIONS
  end

  def build_special_sections_instructions
    danielle_teams = find_danielle_teams_improved
    danielle_info = if danielle_teams.empty?
                      'Look for teams owned by Danielle or similar names, ' \
                        'or use the last place team(s)'
                    else
                      team_names = danielle_teams.map do |t|
                        t['team_name'] || t[:team_name]
                      end.compact
                      owner_names = danielle_teams.map { |t| t['owner'] || t[:owner] }.compact.uniq
                      "Focus on: #{team_names.join(', ')} (owned by: #{owner_names.join(', ')})"
                    end

    # Get a Madison Beer quote based on this week's context
    context_themes = determine_week_themes
    madison_quote = ConfigLoader.select_madison_beer_quote(context_themes)

    <<~SPECIAL
      ## üéµ Special Sections Instructions

      ### Madison Beer Quote of the Week
      Use this actual Madison Beer inspired quote: "#{madison_quote[:text]}"
      - Context: #{madison_quote[:context]}
      - Relate it to this week's fantasy results in a creative way
      - Keep it PG and fun

      ### "Danielle Last Place Watch"
      - #{danielle_info}
      - Provide a humorous update on how Danielle's team is doing
      - If Danielle isn't actually in last place, playfully roast her anyway
      - Include record, recent performance, and chances of avoiding the sacko
      - Make it sound like a sports ticker update but with family sass
    SPECIAL
  end

  def build_tone_and_format_instructions
    <<~TONE
      ## üéØ Tone & Format Guidelines

      **Writing Style:**
      - Family-friendly banter and playful roasting
      - Use emojis liberally but tastefully
      - Include fantasy football terminology but explain it if needed
      - Make everyone feel included in the fun
      - Balance congratulations with gentle ribbing

      **Structure:**
      1. Week Overview (2-3 sentences)
      2. Matchup Breakdowns (one section per matchup)
      3. Waiver Wire Report
      4. Madison Beer Quote of the Week
      5. Danielle Last Place Watch
      6. Looking Ahead (brief teaser for next week)

      **Length:** Aim for 500-800 words total - detailed enough to be engaging but not overwhelming.
    TONE
  end

  def build_data_section
    <<~DATA
      ## üìã Week #{@json_data['week']} Data

      ```json
      #{JSON.pretty_generate(@json_data)}
      ```

      ---

      **Now generate the fun weekly summary using this data and following all the instructions above!**
    DATA
  end

  def extract_owner_names
    names = []

    # Get names from standings
    if @json_data['standings']
      names.concat(@json_data['standings'].map { |team| team['owner'] }.compact)
    end

    # Get names from matchups
    @json_data['matchups']&.each do |matchup|
      matchup['teams']&.each do |team|
        names << team['owner'] if team['owner']
      end
    end

    names.uniq.compact
  end

  def determine_week_themes
    themes = []
    themes.concat(analyze_matchup_themes)
    themes.concat(analyze_standings_themes)
    themes.uniq
  end

  def analyze_matchup_themes
    themes = []
    return themes unless @json_data['matchups']

    @json_data['matchups'].each do |matchup|
      next unless matchup['teams']&.size == 2

      themes.concat(extract_matchup_themes(matchup))
    end

    themes
  end

  def extract_matchup_themes(matchup)
    themes = []
    team1, team2 = matchup['teams']
    margin = matchup['margin'] || 0

    themes << 'close_games' if margin < 10
    themes << 'dominance' if margin > 40

    if team1 && team2
      total_points = (team1['points'] || 0) + (team2['points'] || 0)
      themes << 'high_scoring' if total_points > 250
    end

    themes
  end

  def analyze_standings_themes
    themes = []
    return themes unless @json_data['standings']

    first_place = @json_data['standings'].first
    themes << 'winning_streak' if first_place && (first_place['wins'] || 0) > 1

    last_place = @json_data['standings'].last
    themes << 'struggles' if last_place && (last_place['wins'] || 0).zero?

    themes
  end

  def find_danielle_teams_improved
    return [] unless @json_data['standings']

    # First, check if there are explicitly configured Danielle teams
    explicit_danielle_teams = ConfigLoader.get_special_target_teams('danielle_teams')

    if explicit_danielle_teams.any?
      # Find teams that match the explicit configuration
      return @json_data['standings'].select do |team|
        team_name = team['team_name'] || team[:team_name]
        explicit_danielle_teams.include?(team_name)
      end
    end

    # Fallback to improved search with better owner/team distinction
    ConfigLoader.find_teams_by_owner_or_explicit_mapping(
      @json_data['standings'],
      'danielle',
      %w[dani daniella] # Additional search terms
    )
  end

  # Keep the old method for backwards compatibility
  def find_danielle_teams
    find_danielle_teams_improved
  end

  def build_team_mappings_context
    return '' unless @json_data['standings']

    # Build a list of team-to-owner mappings from the data
    team_owner_pairs = []
    pronoun_info = []

    @json_data['standings'].each do |team|
      team_name = team['team_name'] || team[:team_name] || 'Unknown Team'
      owner_name = team['owner'] || team[:owner] || 'Unknown Owner'

      # Get team info (owner and pronouns)
      team_info = ConfigLoader.get_team_info(team_name)
      actual_owner = team_info[:owner] || owner_name
      pronouns = team_info[:pronouns]

      mapping_text = "- #{team_name} ‚Üí #{actual_owner}"
      mapping_text += ' (explicit mapping)' if team_info[:owner]
      team_owner_pairs << mapping_text

      # Collect pronoun information
      pronoun_info << "- #{actual_owner} uses #{pronouns} pronouns" if pronouns
    end

    return '' if team_owner_pairs.empty?

    context = "\n\n**Team Name to Owner Mappings:**\n#{team_owner_pairs.join("\n")}"

    context += "\n\n**Pronoun Information:**\n#{pronoun_info.join("\n")}" if pronoun_info.any?

    context += "\n\n**IMPORTANT:** Always use the correct owner name when referring to teams. " \
               'Do not confuse team names with owner names. ' \
               'Use the correct pronouns for each person.'

    context
  end
end

# Command line interface
def parse_arguments!
  input_file = nil
  output_file = nil

  ARGV.each_with_index do |arg, i|
    case arg
    when '--input', '-i'
      input_file = ARGV[i + 1]
    when '--output', '-o'
      output_file = ARGV[i + 1]
    when '--help', '-h'
      puts <<~HELP
        Usage: #{File.basename($PROGRAM_NAME)} [options]

        Options:
          --input PATH    Read JSON from file instead of STDIN
          --output PATH   Write prompt to file instead of STDOUT
          --help          Show this help message

        Examples:
          # From piped input
          bin/weekly_summary auto | #{File.basename($PROGRAM_NAME)}

          # From file
          #{File.basename($PROGRAM_NAME)} --input week1_summary.json --output week1_prompt.txt

          # Using environment variables
          SLEEPER_LEAGUE_ID=123456789 bin/weekly_summary auto | #{File.basename($PROGRAM_NAME)}
      HELP
      exit 0
    end
  end

  [input_file, output_file]
end

def main
  input_file, output_file = parse_arguments!

  begin
    # Read JSON data
    json_input = if input_file
                   File.read(input_file)
                 else
                   $stdin.read
                 end

    if json_input.strip.empty?
      warn '‚ùå No input provided. Use --help for usage information.'
      exit 1
    end

    # Generate prompt
    generator = LLMPromptGenerator.new
    prompt = generator.generate_prompt(json_input)

    # Output result
    if output_file
      File.write(output_file, prompt)
      warn "‚úì Generated LLM prompt: #{output_file}"
    else
      puts prompt
    end
  rescue StandardError => e
    warn "‚ùå Error: #{e.message}"
    exit 1
  end
end

main if __FILE__ == $PROGRAM_NAME
